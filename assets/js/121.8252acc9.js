(window.webpackJsonp=window.webpackJsonp||[]).push([[121],{766:function(e,t,o){"use strict";o.r(t);var v=o(12),_=Object(v.a)({},(function(){var e=this,t=e.$createElement,o=e._self._c||t;return o("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[o("h1",{attrs:{id:"expose-声明端口"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#expose-声明端口"}},[e._v("#")]),e._v(" EXPOSE 声明端口")]),e._v(" "),o("p",[e._v("格式为 "),o("code",[e._v("EXPOSE <端口1> [<端口2>...]")]),e._v("。")]),e._v(" "),o("p",[o("code",[e._v("EXPOSE")]),e._v(" 指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务。在 Dockerfile 中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个用处则是在运行时使用随机端口映射时，也就是 "),o("code",[e._v("docker run -P")]),e._v(" 时，会自动随机映射 "),o("code",[e._v("EXPOSE")]),e._v(" 的端口。")]),e._v(" "),o("p",[e._v("要将 "),o("code",[e._v("EXPOSE")]),e._v(" 和在运行时使用 "),o("code",[e._v("-p <宿主端口>:<容器端口>")]),e._v(" 区分开来。"),o("code",[e._v("-p")]),e._v("，是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问，而 "),o("code",[e._v("EXPOSE")]),e._v(" 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。")])])}),[],!1,null,null,null);t.default=_.exports}}]);